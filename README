Pragma Poison static site generator
(c) 2023 William Shaw <will@pragmapoison.org>

What is this?
=============
Pragma Poison Generator is a static website creation tool written in C.  It's meant to be as small and clean 
as possible, so it trades flexibility for simplicity.  In essence, it's a tool for maintaining a website with 
date-stamped, ordered, tagged posts (aka "a blog").  I wrote it for my own site.  If your needs are similar 
to mine, you might find it useful.

I'm aware that there are plenty of other static site generators out there.  There are also far more robust 
Markdown parsers for C, like md4c (https://github.com/mity/md4c/).  This was just a side project that I did for 
fun because I wanted to get back to some basic, useful programming and away from frameworks, APIs, Python, 
anything involving PHP or JavaScript, etc.  Nothing to it but a nice big bag of functions with a legible 
execution flow.  


How does it work?
=================
It parses plaintext data files (YAML + Markdown) and turns them into HTML documents that conform to the HTML5
standard. 

The workflow is:
	1. Create a new site source directory with the generator (i.e., have it make a new directory with 
	   the correct subdirectories and necessary files).  For example, pragma -c /your/site.
	2. Add content to the site by using pragma -s /your/site -n.  This command makes a new text file in
	   /your/site/dat/.  
	3. Edit the new text file.
	4. Preview your 

What input does it expect?
==========================

What output does it generate?
=============================
It creates a complete website in a specified directory, with index.html at the root.  You don't have to specify 
an output directory; the generator will default to the standard output directories in the site directory (./s, 
./c, ./t for the site scroll, posts, and tag index, respectively).  Then you can deploy the site using the 
local_deploy or live_deploy scripts. 

If you specify a different output directory, the site builder will just put the content there.  This setup
can be useful for testing, and it omits the ./dat directory and yaml configuration files.  If you're working in
~/site_staging and want to send your output to /var/www/, you can just do

	pragma -s ~/site_staging -o /var/www

Are there any configuration options?
====================================
A few.  

How do I customize the appearance of my site?
=============================================
There's no support for themes per se, but you can adjust some attributes of the site.  The default CSS file (s.css) 
contains a list of every element class the generator creates.  You can edit this file to change the appearance, 
formatting, and behavior of various page elements.

You can also add functionality to the default JavaScript file (j.js).  This file is empty by default.  


There's a bug
=============
Probably several!  Lots of opportunities for improvement, too.  For example, a lot of HTML formatting is hard-
coded in magic strings, or generated with things like

	wcscat(some_buffer, L"<li><h3"); 

There are some incipient attempts at abstracting a bit of that logic, like the wrap_element() function.  But on
the whole, it's all far short of a truly modular system that abstracts formatting/element generation from other
concerns.  For my purposes, that's fine, and I'll address the limitations as/if needed.  

Other smelly (but technically "fine") things include memory allocation, which could be more efficient in many
places, and the fact that the site skeleton (header, footer, config yaml) is stored entirely in a C header file.
Unicode/wide-character support was added after I started working on the project, and there are places where that
retrofitting is probably evident in the form of sloppiness, needless char/wchar_t conversion routines, etc.

Some design choices reflect a bias toward legibility and simplicity, despite my love of bloated ternary operators.
The scroll generator could make more efficient use of memory with a pointer-to-a-pointer-to-a-pointer list of 
years/months/posts; 

I fix bugs as I discover them and add features as I need them, so the Github repo gets updated, albeit not on 
a regular basis.  Anyone is welcome to incorporate improvements that help others!
